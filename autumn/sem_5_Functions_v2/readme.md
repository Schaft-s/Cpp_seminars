## Повторенье - мать ученья
  - Да, я душнила, но мозг устроен так что надо повторять материал для сохранения его в памяти.
![image](https://github.com/user-attachments/assets/8f40828d-d225-428e-947e-4abcbbdbf9e9)
  - Что я предлагаю вспоминать, это база, основа так сказать:
    - Ссылки и указатели - что есть что и отличия
    - Динамическая память, как заводить массивы, многомерные
    - Тернарный оператор в С++
    - Какие циклы знаете? Сможете назвать 4 штуки?
      
## Функции
  - Зачем?
  - Как писать, что такое возвращаемый тип? что такое аргументы? 
  - Аргументы - пропускать и по умолчанию, при передаче копируются - чтобы избежать ссылки или 
### Перегрузка функций
Это создание несколько функций с одним и тем же именем, но с разными параметрами.  
Компилятор определяет, какую из перегруженных функций использовать, исходя из типов переданных аргументов.
```c++
int multiply(int a, int b) {
    return a * b;
}

double multiply(double a, double b) {
    return a * b;
}
```
  -  Ограничения перегрузки функций
    - Различия в сигнатуре параметров: Функции должны отличаться сигнатурой, т.е. количеством или типами параметров. Нельзя перегружать функции только по возвращаемому типу.
    - Двойной смысл с default значениями: Перегрузка может создавать путаницу, если используются параметры со значениями по умолчанию.
```cpp
int func(int a);
double func(int a); // Ошибка!
int func(int a, int b=0); // Тоже ошибка!
```
    - Ключевые слова const и указатели/ссылки: Перегрузка возможна, если функции различаются наличием/отсутствием const для параметров, указателей или ссылок.
```cpp
void display(int &a);
void display(const int &a); // Это допустимо, так как `const` создаёт уникальную сигнатуру
```
    

### Inline 
Функции, объявленные с ключевым словом inline, подставляются вместо вызова во время компиляции. Это уменьшает накладные расходы, связанные с вызовом функции, но увеличивает размер итогового кода.
_но современные компиляторы часть это делают за вас..._
```inline int func(int x) {}```
_Вроде полезно в заголовочных (.h) файлах, чтобы избегать множественного определения_

### Рекурсия
  - Польза очевидна - удобство, красота, унифицированность
  - Но есть и минусы
    - Затраты на память - всё хранится на стэке и могут быть переполнения
    - Каждый вызов требует сохранения текучего состояния (адрес возврата, параметры, локальные переменные итд). Это приводит к огромным накладным расходам в глубокой рекурсии.
  - Часто можно заменить на итеративные алгоритмы_, хорошие техники прячутся в динамическом программировании_
```c++
int factorial(int n) {
    if (n <= 1) return 1;
    return n * factorial(n - 1);
}
```

### Константные функции
Гарантируют, что не изменяют состояния объекта. Полезно при взаимодействиях с приватными полями классов и просто информацией которую нельзя менять.
```int GetValue() const;```

## Дз / на семинаре
1. Напишите функцию, которая возвращает максимальный и минимальный элементы в динамическом массиве, за O(n). (желательно возвращает указатели на них)
2. Напишите функцию `int* factorize(int n, int &size)`, которая принимает целое число n > 1 и возвращает динамический массив всех простых множителей числа n. Функция также должна возвращать количество множителей через параметр size.
_Используйте динамический массив для хранения множителей.  
Напишите вспомогательную функцию bool isPrime(int n) для проверки простоты числа.  
Необходимо предусмотреть освобождение выделенной памяти для массива после использования._
3. Напишите функцию `void solveHanoi(int n, char from_peg, char to_peg, char aux_peg)`, которая решает задачу Ханойских башен для n дисков. Функция должна выводить шаги, необходимые для переноса всех дисков с начального колышка на конечный.
4. Контест и повторение к тестику.
## Полезные ссылки
  - [Статья](https://habr.com/ru/companies/first/articles/718856/) про запоминание.
  - [Различие](https://stackoverflow.com/questions/24886/is-there-a-performance-difference-between-i-and-i-in-c) между i++ и ++i. (нет)
  - [std::pair](https://en.cppreference.com/w/cpp/utility/pair) - очень полезна я штука
  - 

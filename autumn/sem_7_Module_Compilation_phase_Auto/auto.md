## Считается что вы знаете основную информацию про auto из этого семинара

#### 1. **Недостатки `auto`**

Хотя `auto` обладает множеством преимуществ, есть и определенные недостатки, которые нужно учитывать при его использовании:

##### 1.1. **Неявность типов**

Основной недостаток `auto` — это потеря явности типов. Когда вы используете `auto`, тип выводится компилятором, что может затруднить понимание кода для других программистов (или для вас же в будущем). Это особенно актуально при работе с сложными типами, где явное указание типа может улучшить читабельность.

Пример:
```cpp
auto it = myMap.begin();  // Какой тип у переменной 'it'? Надо смотреть тип контейнера.
```

##### 1.2. **Ошибки при выводе типов**

`auto` выводит тип на основе выражения-инициализатора, и иногда это приводит к неожиданным результатам. Проблемы могут возникнуть, например, при работе с указателями, ссылками и константными значениями.

Пример:
```cpp
const int x = 42;
auto y = x;  // тип y будет int, а не const int
```

Здесь `y` не будет `const`, хотя исходная переменная `x` была константой. _(Так как auto отбрасывает ссылки, это будет обсуждаться ниже)_

#### 2. **Работа `auto` с ссылками и категорией значений**

В C++, когда вы используете `auto`, важно понимать, как он работает с **ссылками** и категориями значений: **lvalue** и **rvalue**.

##### 2.1. **Ссылки и `auto`**

Когда `auto` выводит тип, он может как сохранить ссылку, так и убрать её в зависимости от инициализирующего выражения.

- **Lvalue-ссылки (`T&`)**: если инициализатор является lvalue, `auto` убирает ссылку, если не используется явная ссылка `&`.

Пример:
```cpp
int x = 10;
int& ref = x;
auto y = ref;  // y выводится как int, а не int&
```

Здесь `y` — это копия значения, а не ссылка. Чтобы сохранить ссылку, нужно явно указать `&`:
```cpp
auto& y = ref;  // y - это ссылка на x (int&)
```

- **Rvalue-ссылки (`T&&`)**: если выражение является rvalue, можно использовать rvalue-ссылки. 

Пример:
```cpp
auto&& z = 10;  // z выводится как rvalue-ссылка (int&&)
```

##### 2.2. **Категории значений: lvalue и rvalue**

Категории значений в C++ делятся на два основных типа:

- **Lvalue (left value):** выражение, которое ссылается на область памяти и имеет имя. Lvalue можно брать как по ссылке, так и по указателю.
- **Rvalue (right value):** временное выражение, которое не имеет имени и не сохраняется после завершения выражения.

Когда вы используете `auto`, важно понимать, как категории значений влияют на вывод типов.

- Если `auto` используется с lvalue, то `auto` выводится как обычный тип:
```cpp
int x = 5;
auto a = x;  // a - это int, поскольку x является lvalue
```

- Если `auto` используется с rvalue, то он выводится как значение без ссылки:
```cpp
auto b = 10;  // b - это int, потому что 10 - это rvalue
```

- Если вы хотите сохранить rvalue-ссылку, то следует использовать `auto&&`:
```cpp
auto&& r = 10;  // r - это rvalue-ссылка (int&&)
```

Таким образом, `auto` автоматически адаптируется к категориям значений:

- Lvalue (lvalue-ссылки): требуется явно указать `auto&`, чтобы сохранить ссылку.
- Rvalue (rvalue-ссылки): можно использовать `auto&&` для rvalue-ссылок.

##### 2.3. **Пример работы с lvalue и rvalue:**
```cpp
int x = 10;
auto y = x;    // y - это копия x, тип int
auto& z = x;   // z - это ссылка на x, тип int&

auto&& r1 = x; // r1 - это lvalue-ссылка (int&)
auto&& r2 = 10; // r2 - это rvalue-ссылка (int&&)
```

Здесь:
- `y` — это обычная переменная типа `int`, которая является копией `x`.
- `z` — это lvalue-ссылка на `x`.
- `r1` — это lvalue-ссылка, хотя используется `auto&&`, поскольку `x` — lvalue.
- `r2` — это rvalue-ссылка, так как 10 — это rvalue.

#### 3. **Резюме**

- **Недостатки `auto`:** неявность типов, возможные ошибки при выводе типов, проблемы с указателями и ссылками.
- **Работа с ссылками:** `auto` убирает ссылки по умолчанию, но можно явно указать `&` или `&&`.
- **Категории значений:** lvalue и rvalue влияют на вывод типов, и `auto` корректно обрабатывает ссылки и rvalue, если это необходимо.

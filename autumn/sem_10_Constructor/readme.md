## Повторение
  - Тест одновременный

### Введение в конструкторы

Конструкторы — это специальные функции-члены класса, которые вызываются при создании объекта. Основные задачи конструктора:
1. Инициализировать данные объекта.
2. Убедиться, что объект находится в корректном состоянии.

### Зачем нужны конструкторы?

Конструкторы позволяют задать начальные значения для членов класса и выполнить подготовительные операции, необходимые для корректной работы объекта. Например, если объект представляет собой сложную структуру данных, конструктор может выделить память или выполнить начальные вычисления, требуемые для корректного функционирования.

### Типы конструкторов

1. **Конструктор по умолчанию** — не принимает аргументов и автоматически создается компилятором, если не объявлено других конструкторов.
2. **Пользовательский конструктор** — принимает один или несколько аргументов и используется для инициализации объекта с определенными значениями.
3. _**Копирующий конструктор**_ _(пока не рассматриваем, но можно почитать по ссылке внизу)_ — принимает объект того же класса по константной ссылке и создает его копию. 
4. _**Конструктор перемещения**_ _(пока не рассматриваем, но можно почитать по ссылке внизу)_— принимает временный объект того же класса и перенаправляет ресурсы этого временного объекта в новый объект.

### Конструктор по умолчанию

Конструктор по умолчанию создается компилятором, если не объявлено никаких других конструкторов. Он инициализирует все поля класса значениями по умолчанию (для встроенных типов — это "мусор", если инициализация не указана, для остальных типов — конструктор по умолчанию этого типа).

**Пример:**
```cpp
class Point {
public:
    int x;
    int y;
    
    // Конструктор по умолчанию
    Point() : x(0), y(0) {}
};
```

Если в классе определен хотя бы один конструктор с параметрами, компилятор **не создаст** конструктор по умолчанию. Поэтому, если требуется конструктор без параметров, его необходимо объявить явно.

### Конструктор с одним аргументом

Конструкторы, принимающие один аргумент, часто используются для преобразований типов. Такие конструкторы позволяют инициализировать объект класса значением этого аргумента.

**Пример:**
```cpp
class Temperature {
public:
    double value;
    
    // Конструктор с одним аргументом
    Temperature(double temp) : value(temp) {}
};

int main() {
    Temperature t = 36.6; // неявное преобразование
}
```

#### Явные и неявные преобразования

Когда конструктор имеет один аргумент, компилятор может рассматривать его как средство для **неявного преобразования типов**. В примере выше объект `Temperature` может быть неявно инициализирован значением типа `double`. Это может быть полезно, но иногда ведет к нежелательным преобразованиям и ошибкам.

### Ключевое слово `explicit`

Ключевое слово `explicit` запрещает неявные преобразования с использованием конструктора. Это предотвращает случайное использование конструктора для преобразования типов, что особенно важно при наличии других конструкторов.

**Пример:**
```cpp
class Temperature {
public:
    double value;
    
    // explicit конструктор с одним аргументом
    explicit Temperature(double temp) : value(temp) {}
};

int main() {
    Temperature t1 = 36.6; // ошибка: неявное преобразование запрещено
    Temperature t2(36.6);  // OK: явное использование конструктора
}
```

Использование `explicit` рекомендуется, если конструктор может вызывать нежелательные неявные преобразования. Например, `explicit` помогает избежать ошибок при передаче объектов в функции, где их параметры должны быть определенного типа.

### Списки инициализации 

Списки инициализации в конструкторах позволяют задать значения для членов класса до выполнения тела конструктора. Они особенно полезны, когда члены:
1. Являются `const` или `reference`, так как их можно инициализировать только при создании.
2. Представляют собой объекты классов, у которых нет конструктора по умолчанию.

**Пример списка инициализации:**
```cpp
class Point {
    int x;  // = 0; можно использовать инициализаторы в объявлении (по умолчанию) 
    int y;
public:
    Point(int a, int b) : x(a), y(b) {} // Список инициализации для членов
};
```

Если в классе есть члены, представляющие собой объекты других классов без конструктора по умолчанию, их необходимо инициализировать явно через **список инициализации**. Это требуется, так как такие объекты не могут быть созданы без явного указания аргументов.

**Пример:**

```cpp
class Engine {
public:
    Engine(int power); // Конструктора по умолчанию нет
};

class Car {
    Engine engine;
public:
    Car(int power) : engine(power) {} // Явная инициализация engine
};
```

Здесь объект `engine` инициализируется в списке инициализации конструктора `Car`, чтобы избежать ошибки компиляции.

### Проблемы с конструкторами для нетривиально копируемых типов

Когда конструкторы по умолчанию, копирования и перемещения используются в классе с нетривиальными типами, могут возникнуть проблемы. Например, если класс содержит указатели или другие ресурсы, требуется управлять памятью или другими ресурсами.

#### Решения:

1. **Реализация собственного копирующего и перемещающего конструктора** — управление ресурсами в явной форме.
2. **Запрет на копирование/перемещение** — использование `delete` для запрета копирования или перемещения:

### Пример Array

**Пример:**
```cpp
class Array {
private:
    int* data;
    size_t size;

public:
    Array() : data(nullptr), size(0) {}  // Конструктор по умолчанию
    explicit Array(size_t n) : size(n) {  // Конструктор с одним аргументом
        data = new int[n];
    }
    
    Array(const Array&) = delete;  // Конструктор копирования и оператор присваивания удалены
    Array& operator=(const Array&) = delete;

    ~Array() {
        delete[] data;
    }
};
```

### Тонкости работы конструктора по умолчанию

1. **Если в классе определен хотя бы один конструктор с параметрами, компилятор не будет генерировать конструктор по умолчанию.**
2. **Если в классе присутствуют члены, которые не имеют конструктора по умолчанию, компилятор не сможет создать для этого класса конструктор по умолчанию.**

Это особенно важно, когда класс содержит нестандартные типы или другие классы, не имеющие конструктора по умолчанию. 

**Пример:**
```cpp
class NonDefault {
public:
    NonDefault(int x) {}
};

class MyClass {
    NonDefault member; // Нет конструктора по умолчанию
public:
    MyClass() = delete; // Компилятор не может создать конструктор по умолчанию
};
```

## Полезные ссылки
  - [Статья](https://habr.com/ru/articles/838392/) на хабре про конструкторы (сложнее чем пока знаем)
  - [Совсем сложнее](https://education.yandex.ru/handbook/cpp/article/object-lifetime) от Яндекса, но очень рекомендую почитать. В нашем курсе не рассматриваем пока эти темы, но будем в следующем семестре. Пригодится
  - 

## Что мы прошли?
  - Тестик
  - Указатели-ссылки
  - Массивы-динамические массивы
  - Циклы-функции

## Разделение программы на файлы .h и .cpp
В C++ принято разделять реализацию программы на два типа файлов: заголовочные файлы (с расширением `.h` или `.hpp`) и файлы реализации (с расширением `.cpp`). Такое разделение улучшает читаемость, поддержку и повторное использование кода, а также упрощает работу над большими проектами.

### Заголовочные файлы (`.h`, `.hpp`)
Заголовочные файлы содержат:
- **Объявления** функций, классов и переменных.
- _**Интерфейсы** классов: только объявления методов и полей (без их реализации)._
- **Шаблоны** классов и функций.
- **Макросы** и директивы препроцессора, такие как `#define` и `#include`.
- _**Инлайн-функции** (они реализуются прямо в заголовочных файлах)._
  
Обычно `.h` файл содержит только "декларации" (прототипы) функций, классов и переменных, которые затем будут определены в `.cpp` файле. Это позволяет другим модулям видеть, какие функции и классы существуют, но не знать их внутреннюю реализацию.

#### Пример `.h` файла:
```cpp
// sum.h
#ifndef SUM_H
#define SUM_H

int sum(int a, int b);

#endif // SUM_H
```

### Файлы реализации (`.cpp`)
Файлы реализации содержат:
- **Реализацию** функций, классов и методов, объявленных в заголовочных файлах.
- Включают заголовочные файлы с помощью директивы `#include`.
- Дополнительный код программы, который не требует объявления в заголовочных файлах (например, локальные переменные, вспомогательные функции).

В `.cpp` файле обычно находится код, который дает "жизнь" тому, что было объявлено в `.h` файле.

#### Пример `.cpp` файла:
```cpp
// sum.cpp
#include "sum.h"  // !!!!

int sum(int a, int b) {
    return a + b;
}
```

### Тогда так можно использовать в main.cpp наши файлы
```cpp
#include <iostream>
#include "sum.h"  // !!!!

int main() {
    int x = 3, y = 4;
    std::cout << "Sum of integers: " << sum(x, y) << std::endl;
    return 0;
}
```

### Особенности работы с заголовочными и `.cpp` файлами

1. **Множественное включение заголовочных файлов**:  
   Чтобы избежать многократного включения одного и того же заголовочного файла в разные модули, используется техника "инклюд гвардов" (например, `#ifndef` и `#define`, как показано выше) или директива `#pragma once`.
   
2. **Разделение интерфейса и реализации**:  
   Заголовочные файлы содержат интерфейс программы, который можно использовать в других частях программы, а `.cpp` файлы скрывают детали реализации. Это улучшает инкапсуляцию и модульность кода.

3. **Компиляция**:  
   Компилятор обрабатывает `.cpp` файлы по отдельности, при этом заголовочные файлы включаются в момент компиляции каждого модуля (их содержимое "вставляется" в `.cpp` файлы). На этапе компоновки (linking) все скомпилированные `.cpp` файлы объединяются в один исполняемый файл.

### Работа с шаблонами в заголовочных и `.cpp` файлах

Работа с шаблонами (например, шаблонные классы и функции) в C++ имеет свои особенности. Так как шаблоны являются **компилируемыми только при их использовании**, их реализация должна быть доступна в момент, когда компилятор видит вызов шаблона. Это делает их использование в `.cpp` файлах сложным.

#### Основные подходы:

1. **Реализация шаблонов в заголовочных файлах**:
   Самый распространенный и простой способ работы с шаблонами — это размещение **как объявления**, так и **реализации** шаблонных классов и функций в заголовочных файлах.
   
   Пример шаблонной функции в заголовочном файле:
   ```cpp
   // my_template.h
   #ifndef MY_TEMPLATE_H
   #define MY_TEMPLATE_H

   template <typename T>
   T sum(T a, T b) {
       return a + b;
   }

   #endif // MY_TEMPLATE_H
   ```

2. **Шаблоны в `.cpp` файлах** (специализация):
   Если нужно разделить объявление и реализацию шаблона по разным файлам, можно использовать явную специализацию. Например, можно реализовать шаблон в `.cpp` файле, но при этом придется **явно специализировать** его для конкретных типов:
   
   Пример:
   ```cpp
   // my_template.h
   template <typename T>
   T sum(T a, T b);
   
   // my_template.cpp
   #include "my_template.h"
   
   template <>
   int sum<int>(int a, int b) {
       return a + b;
   }
   ```

3. **Инстанцирование шаблонов**:
   В некоторых случаях можно применить технику явного инстанцирования (explicit instantiation), когда объявление и реализация шаблона разделяются по разным файлам, но компилятору указывают, какие инстанции шаблона следует создать.

   Пример явного инстанцирования:
   ```cpp
   // my_template.h
   template <typename T>
   T sum(T a, T b);

   // my_template.cpp
   #include "my_template.h"

   template <typename T>
   T sum(T a, T b) {
       return a + b;
   }

   template int sum<int>(int, int);  // Явное инстанцирование для типа int
   ```

### Резюме
- **.h файлы** используются для объявлений функций, классов и переменных, а **.cpp файлы** — для их реализации.
- Шаблонные функции и классы обычно реализуются в заголовочных файлах, поскольку их код должен быть доступен во время компиляции любого файла, который использует шаблон.
- Для избежания проблем с множественным включением файлов применяются инклюд гварды или директива `#pragma once`.


## Шаблоны функций
### 
  - `template <class T> или template <typename T>`
```c++
template <class T, class U>
void Print(T x, U y) { std::cout << x << ' ' << y; }
```
  - Нужна однозначность для определения типа. Иначе СЕ. Можно _подсказывать_ `Print<long, long>(1, 1);`
  - Можно передавать аргументы по ссылке (в самой функции).
  - Можно указывать шаблоны по умолчанию `template <class T = int>` или так `template <class T, class U = T>`
  - 
### Вывод типа шаблона
  - При передаче аргумента по значению тип T выводится по следующим правилам:
1. CV-квалификаторы ( const , volatile ) игнорируются.
2. Ссылки отбрасываются.
3. Массивы низводятся до указателей.
4. Функции низводятся до указателей на функцию.
5. Типы соответствующие одному шаблонному типу T должны совпадать(после выполнения всех действий выше).
### Инстанцирование шаблона
  - Пока шаблон явно не вызван - не происходит генерация его кода.
  - Можно явно попросить `template void f(float);`
### Перегрузка и спецификация шаблонов

## Домашнее задани
  - Контест
  - Задачки:
    1. _Перед семинаром вставлю_
    2. 
## Полезные ссылки
  - Как обычно хендбук от Яндекса, [тут](https://education.yandex.ru/handbook/cpp/article/templates)
  - [Статья](https://habr.com/ru/articles/599801/) про шаблоны в С++, пока читаем первые 2 пункта.

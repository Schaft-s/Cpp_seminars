### Шаблоны в C++

Шаблоны (templates) позволяют создавать обобщенный код, который может работать с разными типами данных. Это одна из ключевых особенностей C++, позволяющая писать более гибкие и повторно используемые компоненты. Существует два основных типа шаблонов:

1. **Функциональные шаблоны** — позволяют создавать функции, работающие с любым типом данных.
   ```cpp
   template <typename T>
   void swap(T& a, T& b) {
       T temp = a;
       a = b;
       b = temp;
   }
   ```

2. **Классовые шаблоны** — позволяют создавать классы, где типы данных могут быть параметризованы.
   ```cpp
   template <typename T>
   class MyContainer {
       T* data;
       // ...
   };
   ```

Шаблоны повышают уровень абстракции, позволяя минимизировать дублирование кода, при этом сохраняя производительность на уровне, близком к написанию кода для каждого типа отдельно.

### Диапазоны в STL

Диапазоны (ranges) в STL работают через пару итераторов: `begin` и `end`. Эти итераторы указывают на начало и конец последовательности в контейнере. Диапазоны позволяют алгоритмам STL работать с любым контейнером, который поддерживает итераторы (например, массивы, списки, векторы и т.д.).

#### Пример работы с диапазонами:

Допустим, у нас есть массив:

```cpp
int arr[] = {1, 2, 3, 4, 5};
```

Мы можем передать этот массив в алгоритм `std::copy`, используя диапазон:

```cpp
std::copy(std::begin(arr), std::end(arr), std::ostream_iterator<int>(std::cout, " "));
```

Здесь:
- `std::begin(arr)` возвращает итератор на начало массива.
- `std::end(arr)` возвращает итератор на элемент за последним элементом массива (не включается в диапазон).

### Итераторы и их типы

STL использует итераторы для абстрагирования доступа к элементам контейнеров. Итераторы можно представить как указатели, которые могут перемещаться по контейнеру. Есть несколько типов итераторов:

1. **Input и Output итераторы** — позволяют читать или записывать данные по элементам последовательности.
2. **Forward итераторы** — позволяют перемещаться вперед по последовательности.
3. **Bidirectional итераторы** — позволяют перемещаться как вперед, так и назад.
4. **Random Access итераторы** — поддерживают произвольный доступ к элементам, как указатели.

Алгоритмы, такие как `std::fill`, `std::copy` или `std::binary_search`, используют итераторы для работы с диапазонами.

### Преимущества использования диапазонов

1. **Абстракция:** Алгоритмы могут работать с любым контейнером, который предоставляет итераторы, будь то массив, вектор или список.
2. **Гибкость:** Одни и те же алгоритмы можно применять к разным типам данных, как только они поддерживают интерфейс итераторов.
3. **Безопасность:** Использование диапазонов позволяет уменьшить риск выхода за пределы контейнера, так как итераторы четко указывают начало и конец.


### 1. Шаблонный `swap`

Функция `swap` обменивает значения двух переменных:

```cpp
template <typename T>
void swap(T& a, T& b) {
    T temp = a;
    a = b;
    b = temp;
}
```

### 2. Шаблонный `copy`

`copy` копирует элементы из одного диапазона в другой:

```cpp
template <typename InputIt, typename OutputIt>
OutputIt copy(InputIt first, InputIt last, OutputIt d_first) {
    while (first != last) {
        *d_first++ = *first++;
    }
    return d_first;
}
```

### 3. Шаблонный `fill`

`fill` заполняет диапазон определенным значением:

```cpp
template <typename ForwardIt, typename T>
void fill(ForwardIt first, ForwardIt last, const T& value) {
    while (first != last) {
        *first++ = value;
    }
}
```

### 4. Шаблонный `binary_search`

Алгоритм `binary_search` предполагает, что диапазон отсортирован:

```cpp
template <typename ForwardIt, typename T>
bool binary_search(ForwardIt first, ForwardIt last, const T& value) {
    ForwardIt it;
    auto count = std::distance(first, last);
    while (count > 0) {
        it = first;
        auto step = count / 2;
        std::advance(it, step);
        if (*it < value) {
            first = ++it;
            count -= step + 1;
        } else {
            count = step;
        }
    }
    return (first != last && !(value < *first));
}
```

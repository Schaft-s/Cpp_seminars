## Повторение 
  - Тестик + разбор его
  - Не вошедшее
  - Самое большое целое число какое можем и куда влезет?
  - Что делают `cd mkdir vim nano.. whereami whoami` в Linux ?
  - Что такое короткая логика ?
  - Зачем использовать switch ?
  - Как записывается тернарная операция ?
    
## Семинар 3 - Указатели и массивы

### Ссылки -  `&`
  - При инициализации одного объекта от другого происходит копирование.
```с++
int x = 42;
int rx_ = x;

x++;
std::cout << rx_ << "\n";
```
  - Cсылки! Теперь не копируем и ссылаемся на ту же самую область памяти..
```с++
int x = 42;
int &rx_ = x;

x++;
std::cout << rx_ << "\n";
```
  - Сложности: должна быть проинициализирована в момент объявления и не может указывать на разные области.
```c++
int &rx; // CE
int &rx = x;
&rx = y;
```
  #### Фан-факты:
  - Могут на одну переменную ссылаться несколько ссылок
  - Все операции применяемые к ссылке применяются к переменной: это касается и таких операторов, как = (присваивание), & (получение адреса), sizeof, typeid. _Но вот спецификатор decltype, если его применить к ссылке, дает ссылочный тип._
```с++
int x = 1, y = 2;
int &rx= x, &ry = y;
rx = ry;
// ==
x = y;
```
  - Дальше мы не пока не готовы.  _но можно почитать статью оставленную ниже_
<img src="https://github.com/user-attachments/assets/249f1294-50fc-43a3-8d10-38a3cc0c47a1" alt="Alt Text" width="300" height="200">

### Указатели
  - А давайте будем хранить адрес памяти - желательно чтобы в нём что-то лежало... _(спойлер: можем и на мусор смотреть, если очень хочется/ошиблись)_
```c++
int x = 42;
int* ptr = &x;  // сохраняем адрес в памяти переменной x в указатель ptr

++x;  // увеличим x на единицу
std::cout << *ptr << "\n";  // 43  * это разыменование указателя
```  
  - Внутри себя указатель хранит адрес И тип на который ссылается! При этом можно делать указатель от указателя
  - Существует `nullptr` чтобы пустоту показывать.
  - Можно складывать  указатели с числами - это сдвиг по памяти. (кроме void* - это отдельный тип)
```c++
int arr[5] = {1, 2, 3, 4, 5};
int *ptr = arr; // ptr указывает на первый элемент массива

*(ptr + 1) = 10; // Изменение значения второго элемента массива (arr[1])
ptr += 2;        // ptr теперь указывает на третий элемент массива (arr[2])
int num1 = 10, num2 = 20;
int *ptr1 = &num1, *ptr2 = &num2;
if (ptr1 < ptr2) { // Сравнение адресов ... }
```
  - Можно вычитать из одного указателя другой - покажет расстояние в байтах между ними разделённое на размер типа данных... Обычно внутри одного массива
```c++
int arr[5] = {1, 2, 3, 4, 5};
int *ptr1 = &arr[1];
int *ptr2 = &arr[3];

int diff = ptr2 - ptr1; // diff будет равно 2

/////////////////////////////

int x = 0;
double y = 1;
int* px = &x;
double* py = &y;

// Приведение к void* для получения разницы в байтах
std::ptrdiff_t diff_bytes = reinterpret_cast<char*>(py) - reinterpret_cast<char*>(px);
std::cout << diff_bytes; // Выведет разницу в байтах между адресами
```
  - Обращение к полям структур
```c++
struct Point {
    double x, y, z;
};

int main() {
    Point p = {3.0, 4.0, 5.0};

    Point* ptr = &p;

    std::cout << (*ptr).x << "\n";  // обращение через * и . требует скобок
    std::cout << ptr->x << "\n";  // то же самое, но чуть короче
}
```
### Память в С++
#### Статическая память (Глобальная)
  - Выделяется на этапе компиляции и остаётся фиксированной в течении всей работы программы
  - Примеры: Глобальные и статические переменные
  - Особенности:
    - Инициализация нулями
    - Не выделяется дополнительно по ходу программы
#### Автоматическая (Стэковая)
  - Выделяется и освобождается в рамках выполнения функции или блока кода.
  - Примеры: Локальные переменные в функциях.
  - Особенности:
    - Хранится в стеке.
    - Инициализирована случайным образом (неопределённое значение) если не инициализирована явно.
    - Освобождается автоматически при выходе из области видимости.
#### Динамическая память
  - Выделяется во время выполнения программы по запросу.
  - Примеры: Использование new и delete для выделения и освобождения памяти.
  - Особенности:
    - Хранится в куче (heap).
    - Требует явного управления жизненным циклом (выделение и освобождение памяти).
    - Позволяет выделять память переменного размера.

### Массивы
#### Обычные (статические)
  - Массивы с фиксированным размером, который определяется на этапе компиляции.
  - `int arr[compile_time_const_value];` - размер фиксирован на этапе компиляции
  - Особенности:
    - Размер массива задаётся при компиляции и не может быть изменён в процессе выполнения программы.
    - Память выделяется на стеке для локальных массивов или в сегменте данных для глобальных и статических массивов.
    - Обращение к элементам массива выполняется за константное время.
#### Динамические
  - Массивы, размер которых может изменяться во время выполнения программы.
```c++
int* arr = new int[10]; // выделение массива из 10 целых чисел
// Использование массива
delete[] arr; // освобождение памяти
```
  - Особенности:
    - Размер массива определяется во время выполнения с помощью динамического выделения памяти.
    - Память выделяется в куче и требует явного управления с помощью new и delete или new[] и delete[].
    - Поддерживает изменение размера с помощью realloc (в C) или аналогичных методов.

## ДЗ 
  - Повторение материала перед лекцией и тестиком
  - Контест - будет ссылка тут
  - Прочитать первые 4 параграфа из хэндбука Яндекса
## Полезные ссылки
  - Из [учебника](https://education.yandex.ru/handbook/cpp/article/references-pointers-const) Яндекса часть про ссылки и указатели.
  - [Статья](https://habr.com/ru/companies/jugru/articles/469465/) про все виды инициализации
  - [Stdendl & \n](https://stackoverflow.com/questions/213907/stdendl-vs-n)
  - [Статья](https://habr.com/ru/articles/646005/) где по ощущениям есть ВСЁ про ссылки...
  - 

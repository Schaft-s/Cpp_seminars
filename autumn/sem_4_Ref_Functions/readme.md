## Повторение
  - Тестик
  - Не вошедшее
  - Уже успели забыть?

```с++
x++;  // читаем слева направо, встретили х - вернули, потом добавили ++
++x;  // встретили ++ - добавили, потом возвращаем
int x = 0;
std::cout << ++x << '\n'; // 1 (x == 1)
std::cout << x++ << '\n'; // 1 (x == 2)
--x = 10; // x == 10
x-- = 11; // CE
```
<img src="https://github.com/user-attachments/assets/73bde8a1-3aca-47fa-9e08-ae0f451a9be2" alt="Alt Text" width="600" height="250">

# Напоминание про различие ссылок и указателей
#### Ссылки
  - **Определение:** Ссылка — это альтернативное имя для переменной, подобно указателю, но без необходимости разыменования.
    - Ссылка должна быть инициализирована при создании и не может быть изменена, чтобы указывать на другую область памяти.
    - **Ограничения:** Нельзя создавать ссылку на ссылку, ссылку на void, или массив ссылок.
  - **Особенность с rvalue:** Можно создавать константную ссылку на временные (rvalue) объекты. Это позволяет продлить жизнь временного объекта:
```c++
// int& x = 0; // так нельзя
const int& cx = 0; // а так можно
```
#### Указатели
  - Указатели содержат адрес памяти, в которой хранится объект, а также тип данных, на который они указывают.
    - Можно получить объект по адресу через операцию разыменования * и изменять его.
    - **Арифметика указателей:** Возможность прибавлять и вычитать значения к указателю, изменяя адрес, на который он указывает.
    - Поддержка **nullptr** — специального значения, означающего, что указатель не указывает ни на какой объект.
    - Возможность создания указателей на указатели, что позволяет организовывать сложные структуры данных.
```c++
int arr[3] = {1, 2, 3};  // Если завести просто int x=1,y=2,z=3; - также?
int* ptr = arr;
std::cout << *ptr << std::endl; // 1
ptr++;
std::cout << *ptr << std::endl; // 2
```
## Функции
  - Функции — это ключевой элемент модульного программирования. Они позволяют повторно использовать код и делать его более структурированным.
  - Это также актуально для отладки решения.
```c++
ReturnType Name(Type1 p1, Type2 p2, ...) {
// тело функции
}
```
  - Необходимо объявить перед использованием! При можно разделить **объявление** и **определение:**
```c++
int Max(int x, int y); // Объявление функции
int main() { // тут использование Max}
int Max(int x, int y) { return x > y ? x : y; } // Определение функции
```
  - В **объявлении** можно
    - опускать имена параметров `Max(int, int)`
    - писать несколько объявлений
    - использовать аргументы по умолчанию (_только последние несколько_)
  - В **определении:**
    - необходимо описать все имена параметров.
    - Не необходимо повторять параметры по умолчанию.
    - **ODR** - One Definition Rule - определение обязано быть одно!

### Аргументы функции == Параметры
  - При передаче в функцию параметры копируются - это хорошо или плохо? Что если мы хотим изменить переменную передаваемую в функцию? _swap?_
  - Передача по ссылке или указателю
```c++
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
    int z = x;
    x = y;
    y = z;
}

int main() {
    int a = 0, b = 1;
    Swap(a, b);  // Что будет если написать - Swap(0,1); 
    std::cout << a << " " << b << "\n";  // 1 0
}
```
  - Также передача по ссылке полезна при использовании тяжёлых объектов или больших структур, во избежании копирования. Если знаем что не будем изменять объект - можно использовать передачу по константной ссылке `void f(const std::vector<int>& v) {}`.
  - Как передать массив?
    - Желательно дать указатель и размер. 
    - Для извращенцев - `void f(int (*array_ptr)[50]);`
    
### Возвращаемые значения
  - Необходимо указывать тип возвращаемого значения. И возвращать только его... это не питон, базовые типы преобразуются друг в друга, даже _ковариантные_ схлопнутся, но лучше знать что возвращаешь. Если тип большой и страшный, то можно писать волшебную конструкцию о которой будем говорить позже: 
```c++
template <typename T>
auto move(T&& value) -> std:remove_reference_t<T>&&
{
  return static_cast<std::remove_reference_t<T>&&>(value);
}
```
  - `return` возвращает значение, их может быть много. После него полностью прекращается работа функции, заканчивается цикл, если были внутри, удаляются все локальные переменные. `Else` после `return` не нужно и на это будет ругаться компилятор и кодстайл-чекер.
  - Если функция ничего не вернёт - ошибки не будет, но обращение к результату вызовет UB. Можно использовать тип `void` если не хотим ничего возвращать. С ним можно использовать return без параметров.


## Динамическое выделение памяти - продолжение
- **Динамическая память**: Память, выделяемая в куче (heap) во время выполнения программы.
- **`new` и `delete`**: Операторы для выделения и освобождения памяти.
```c++
int *x = new int{1};  // возвращается указатель
int *y = new int[10];  // тоже указатель!
// не забываем чистить (причёт по разному)
delete x;
delete[] y;
```
### Утечка памяти:
- это ситуация, когда программа не освобождает память после ее использования. 
- **Демонстрация утечки**:
  ```cpp
  for (int i = 0; i < 1000; ++i) {
      int* leak = new int[1000]; // Память не освобождается
  }
  // Можно наблюдать рост потребления памяти в диспетчере задач
  ```

## Многомерные динамические массивы
### "Массив массивов" (подход с массивом указателей):

- **Пример**:
  ```cpp
  int rows = 3, cols = 4;
  int** matrix = new int*[rows];
  for (int i = 0; i < rows; ++i) {
      matrix[i] = new int[cols];
  }
  // Использование массива
  for (int i = 0; i < rows; ++i) {
      delete[] matrix[i];
  }
  delete[] matrix;
  ```

### Выделение единого блока для многомерного массива:

- **Пример**:
  ```cpp
  int* data = new int[rows * cols];
  int** matrix = new int*[rows];
  for (int i = 0; i < rows; ++i) {
      matrix[i] = &data[i * cols];
  }
  // Использование массива
  delete[] matrix;
  delete[] data;
  ```

---

## Работа с нуль-терминированными строками (библиотека `cstring`)
- **Нуль-терминированная строка**: Строка символов, оканчивающаяся символом `'\0'`.
- Презентация от лектора [тут]('CString.pdf'). Предоставлена Ибрагимовым Булатом Ленаровичем для студентов МФТИ.

### Нуль-терминированные строки
**Нуль-терминированная строка** (C-string) — это массив символов, заканчивающийся специальным символом `\0` (нуль-символ), который обозначает конец строки. Нуль-терминированные строки обычно используются в более низкоуровневых задачах, например, при взаимодействии с C-библиотеками или для максимальной производительности.

#### Создание и работа с нуль-терминированными строками:
```cpp
char str[] = "Hello, World!"; // Массив символов, заканчивающийся '\0'
const char* str2 = "Hello"; // Указатель на строку в статической памяти
```

В массиве `str[]` автоматически добавляется символ `\0` в конец строки. В строке `str2` этот символ тоже добавляется, но строка располагается в области памяти, предназначенной для неизменяемых данных.

#### Основные функции для работы с C-строками:
Для работы с нуль-терминированными строками в C++ существует множество функций из библиотеки `cstring`.

1. **`strlen`** — вычисление длины строки (без учета символа `\0`):
    ```cpp
    const char* str = "Hello";
    size_t len = strlen(str); // len = 5
    ```
2. **`strcpy`** — копирование одной строки в другую:
    ```cpp
    char dest[10];
    const char* src = "World";
    strcpy(dest, src); // dest теперь содержит "World"
    ```
3. **`strcat`** — конкатенация (объединение) строк:
    ```cpp
    char dest[20] = "Hello, ";
    const char* src = "World!";
    strcat(dest, src); // dest теперь содержит "Hello, World!"
    ```
4. **`strcmp`** — сравнение строк:
    ```cpp
    const char* str1 = "Hello";
    const char* str2 = "World";
    if (strcmp(str1, str2) == 0) {
        std::cout << "Строки одинаковы";
    } else {
        std::cout << "Строки разные";
    }
    ```
#### Важные аспекты работы с C-строками:
- **Память**: Нужно быть осторожным с выделением памяти. Например, при копировании строк необходимо убедиться, что буфер назначения достаточно велик, чтобы вместить исходную строку и символ `\0`. Несоблюдение этого может привести к переполнению буфера и ошибкам выполнения.
  
  Пример неправильного кода:
  ```cpp
  char dest[5];
  const char* src = "Hello";
  strcpy(dest, src); // Ошибка: dest слишком мал для копирования "Hello"
  ```

- **Управление памятью**: Важно следить за тем, чтобы освобождать динамически выделенную память при работе с C-строками, если память выделялась вручную с помощью `new`:
  ```cpp
  char* str = new char[100];
  // работа со строкой
  delete[] str; // освобождение памяти
  ```

## Резюме
- Важность правильного управления памятью, чтобы избежать утечек.
- Использование динамических структур данных может сделать программы более гибкими и эффективными.
- Необходимость работы с низкоуровневыми строками в контексте совместимости и производительности.
    
## Домашнее задание
  - Контест домашний
  - Завести два массива друг за другом и гуляя по памяти через указатели найти через первый - второй.
  - Наконец-то потратить 15 минут и почитать статьи из прошлых полезных ссылок.
  - Что происходит? ```int main() {[](){}();}```
    
## Полезные ссылки
  - [Яндекс](https://education.yandex.ru/handbook/cpp/article/functions) про функции.
  - [Статья](https://habr.com/ru/articles/414443/) про функции под капотом.
  - [Статья](https://habr.com/ru/articles/748336/) про вывод форматированного текста в С++. В плюсах есть свой std::print !!

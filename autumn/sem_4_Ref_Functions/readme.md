## Повторение
  - Тестик
  - Не вошедшее
  - Уже успели забыть?

```с++
x++;  // читаем слева направо, встретили х - вернули, потом добавили ++
++x;  // встретили ++ - добавили, потом возвращаем
int x = 0;
std::cout << ++x << '\n'; // 1 (x == 1)
std::cout << x++ << '\n'; // 1 (x == 2)
--x = 10; // x == 10
x-- = 11; // CE
```
<img src="https://github.com/user-attachments/assets/73bde8a1-3aca-47fa-9e08-ae0f451a9be2" alt="Alt Text" width="600" height="250">

## Ссылки и функции
### Напоминание про различие ссылок и указателей
#### Ссылки
  - Альтернативное имя переменной. _указатель без необходимости разыменовывать_
    - Привязаны к области памяти. Нельзя переставить на другую область (переменную).
    - Необходимо инициализировать при создании.
    - Нельзя создавать ссылку на ссылку, ссылку на void, массив ссылок
  - Можно создавать константную ссылку на rvalue! Продлеваем жизнь временного объекта
```c++
// int& x = 0; // так нельзя
const int& cx = 0; // а так можно
```
#### Указатели
  - Содержат в себе _область памяти_(номер) И тип хранимого объекта.
    - Можно получить хранимый объект _(разыменование = *)_ и менять его.
    - Арифметика указателей..
    - **nullptr**
    - Указатели на указатели на указатели на указатели на....
  - Основная сущность с++. Гуляем по массиву и по памяти почти бесплатно.
    
### Функции
  - Функции позволяют отделить часто используемый код и/или использовать его с разными значениями аргументов.
  - Это также актуально для отладки решения.
```c++
ReturnType Name(Type1 p1, Type2 p2, ...) {
// тело функции
}
```
  - Необходимо объявить перед использованием! При можно разделить объявление и определение:
```c++
int Max(int x, int y); // Объявление функции
int main() { // тут использование Max}
int Max(int x, int y) { return x > y ? x : y; } // Определение функции
```
  - В объявлении можно
    - опускать имена параметров `Max(int, int)`
    - писать несколько объявлений
    - использовать аргументы по умолчанию (_только последние несколько_)
  - В определении:
    - необходимо описать все имена параметров.
    - Не необходимо повторять параметры по умолчанию.
    - ODR - One Definition Rule - определение обязано быть одно!

### Аргументы функции == Параметры
  - При передаче в функцию параметры копируются - это хорошо или плохо? Что если мы хотим изменить переменную передаваемую в функцию? _swap?_
  - Передача по ссылке или указателю
```c++
void Swap(int& x, int& y) {  // передаём аргументы по ссылке
    int z = x;
    x = y;
    y = z;
}

int main() {
    int a = 0, b = 1;
    Swap(a, b);  // Что будет если написать - Swap(0,1); 
    std::cout << a << " " << b << "\n";  // 1 0
}
```
  - Также передача по ссылке полезна при использовании тяжёлых объектов или больших структур, во избежании копирования. Если знаем что не будем изменять объект - можно использовать передачу по константной ссылке `void f(const std::vector<int>& v) {}`.
    
### Возвращаемые значения
  - Необходимо указывать тип возвращаемого значения. И возвращать только его... Если тип большой и страшный, то можно писать волшебную конструкцию о которой будем говорить позже: 
```c++
template <typename T>
auto move(T&& value) -> std:remove_reference_t<T>&&
{
  return static_cast<std::remove_reference_t<T>&&>(value);
}
```
## Домашнее задание
  - Контест домашний
  - Завести два массива друг за другом и гуляя по памяти через указатели найти через первый - второй.
  - Наконец-то потратить 15 минут и почитать статьи из прошлых полезных ссылок.
  - Что происходит? ```int main() {[](){}();}```
## Полезные ссылки

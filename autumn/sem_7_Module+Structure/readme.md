## Повторение

## Модульное программирование
###

### Составные типы данных

C++ позволяет создавать новые типы данных на основе базовых. Это можно делать с помощью перечислений (enum), структур (struct), классов (class), а также стандартных контейнеров, таких как `std::pair` и `std::tuple`. Рассмотрим каждый из этих механизмов подробнее.

#### Перечисления (enum)

Перечисление — это набор именованных констант, которые обычно используются для описания возможных состояний или опций. Например, перечисление возрастные группы:

```cpp
enum class Age {
    Child,
    Teen,
    Adult,
    Old
};
```

Перечисления удобны тем, что дают программам читабельность и безопасность типов. Их можно преобразовывать в числа и обратно с помощью `static_cast`:

```cpp
int value = static_cast<int>(Age::Old);  // 3
Age age = static_cast<Age>(2);  // Age::Adult
```
Вот более подробное изложение темы **структур в C++**, основанное на твоей презентации и дополнительной информации.

### Определение и Инициализация Структур

**Структура** — это составной тип данных, который инкапсулирует набор данных разных типов под одним именем. Она используется для представления более сложных объектов, которые содержат несколько полей. В C++ структура объявляется с помощью ключевого слова `struct`.

Пример структур, комплексное число и массив:

```cpp
struct Complex {
    double re;  // действительная часть
    double im;  // мнимая часть
};

struct Array {
    int* buffer;
    size_t size;
};
```

Объявление структуры создаёт новый тип данных, который можно использовать для создания переменных:

```cpp
Complex number;
number.re = 1.0;
number.im = -2.5;
```

#### Инициализация Структур

C++ позволяет инициализировать структуры как через список инициализаторов, так и с помощью фигурных скобок. Если не указать некоторые значения при инициализации, поля будут автоматически обнулены:

```cpp
struct Point {
    int x = 0;
    int y = 0;
};

Point p1 = {10, 20};  // x = 10, y = 20
Point p2 = {5};       // x = 5, y = 0
Point p3;             // x = 0, y = 0
```

Начиная с C++20, доступны **designated initializers**, позволяющие явно указывать, какие поля структуры инициализируются:

```cpp
Point p4 = {.x = 1, .y = 2};
```

### Доступ к Полям

Для доступа к полям структуры используется операция `.`:

```cpp
Point p = {1, 2};
std::cout << p.x << " " << p.y << std::endl;
```

### Статические Поля в Структурах

**Статические поля** принадлежат структуре в целом, а не её экземплярам. Их можно использовать для хранения общих данных для всех объектов структуры. Они объявляются с использованием ключевого слова `static` и должны быть определены отдельно:

```cpp
struct S {
    static int counter;
};

int S::counter = 0;
```

Обращение к статическим полям выполняется через имя структуры:

```cpp
S::counter = 10;
```

### Размещение Структур в Памяти и Выравнивание [3]

Размер структуры в памяти зависит не только от размеров её полей, но и от выравнивания. Компилятор может добавлять "пустые" байты для оптимизации доступа к данным, особенно если поля имеют разные размеры. Это влияет на общий размер структуры.

Пример:

```cpp
struct S {
    char c;     // 1 байт
    int32_t i;  // 4 байта
    int16_t s;  // 2 байта
    int64_t l;  // 8 байт
};

std::cout << sizeof(S);  // 24, а не 15, из-за выравнивания
```

**Правильное упорядочение полей** может уменьшить размер структуры, так как уменьшается количество "пустых" байтов:

```cpp
struct Optimized {
    int64_t l;  // 8 байт
    int32_t i;  // 4 байта
    int16_t s;  // 2 байта
    char c;     // 1 байт
};

std::cout << sizeof(Optimized);  // 16
```

### Копирование Структур
В C++ структуры по умолчанию копируются **побитово**. Это означает, что все поля структуры копируются как есть, даже массивы:

### Доступ к Полям через Указатель

Чтобы обращаться к полям структуры через указатель, используется операция `->`:

```cpp
Point* p = new Point{10, 20};
p->x = 30;
```
#### Пары (std::pair) и кортежи (std::tuple)

Для хранения двух и более объектов используются шаблонные структуры `std::pair` и `std::tuple`:

```cpp
std::pair<int, double> p = {42, 3.14};
std::tuple<int, double, Point> t = {42, 3.14, point1};
```

К элементам `std::tuple` можно обращаться через `std::get<>`:

```cpp
std::cout << std::get<0>(t);  // 42
```

Также можно распаковывать данные с помощью structured bindings:  [3]  

```cpp
auto [x, y, point] = t;
```
## ДЗ
  - Контест
  - Задачку одну сохранял, попросите на паре если интересно
## Полезные ссылки
- [0] [Учебник](https://education.yandex.ru/handbook/cpp/article/complex-data-types) Яндекса на тему.
- [1] [Статья](https://habr.com/ru/articles/334988/) на хабре про struct, union, enum.
- [2] [Статья](https://tproger.ru/translations/art-of-structure-packing) про выравнивание
- [3] [Статья](https://habr.com/ru/companies/playrix/articles/465181/) где рассказывается про структурное связывание

Пока не знаю в каком семинаре это будет, но когда-то расскажется.

### Работа с нуль-терминированными строками и `std::string`

Строки в C++ бывают двух типов:
1. **Нуль-терминированные строки** (C-строки). - про них рассказано в 4-ом семинаре.
2. **Класс `std::string`** из библиотеки Standard Template Library (STL).

### Класс `std::string`
Стандартный класс `std::string` предоставляет гораздо более удобные и безопасные возможности работы со строками по сравнению с нуль-терминированными строками. Он избавляет от необходимости вручную управлять памятью и предотвращает многие распространенные ошибки.

#### Основные операции с `std::string`:
1. **Создание строк**:
    ```cpp
    std::string str1 = "Hello";
    std::string str2("World");
    ```

2. **Конкатенация строк**:
    ```cpp
    std::string greeting = str1 + ", " + str2 + "!";
    std::cout << greeting; // Вывод: Hello, World!
    ```

3. **Получение длины строки**:
    ```cpp
    std::string str = "Hello";
    size_t len = str.length(); // len = 5
    ```

4. **Изменение строки**:
    - Добавление символов или подстроки:
    ```cpp
    std::string name = "John";
    name += " Doe"; // name теперь "John Doe"
    ```

    - Вставка подстроки:
    ```cpp
    std::string str = "Good Day";
    str.insert(5, "Morning "); // str = "Good Morning Day"
    ```

5. **Доступ к символам**:
    - Через метод `.at()` с проверкой границ:
    ```cpp
    char ch = str.at(0); // ch = 'G'
    ```

    - Через оператор индексации `[]` (без проверки):
    ```cpp
    char ch = str[0]; // ch = 'G'
    ```

6. **Изменение символов**:
    ```cpp
    std::string str = "Hello";
    str[0] = 'Y'; // str теперь "Yello"
    ```

7. **Поиск подстроки**:
    - Метод `.find()` возвращает индекс первого вхождения подстроки:
    ```cpp
    std::string str = "Hello, World!";
    size_t pos = str.find("World"); // pos = 7
    ```

    - Метод `.substr()` извлекает подстроку:
    ```cpp
    std::string str = "Hello, World!";
    std::string sub = str.substr(7, 5); // sub = "World"
    ```

#### Преимущества `std::string` перед C-строками:
- **Автоматическое управление памятью**: `std::string` сам управляет выделением и освобождением памяти. Не нужно беспокоиться о переполнении буфера или утечках памяти.
  
- **Безопасность**: Методы класса `std::string`, такие как `.at()`, выполняют проверку границ массива, что предотвращает доступ за пределы строки.

- **Функциональность**: `std::string` предоставляет множество встроенных методов для работы со строками, таких как конкатенация, поиск, замена, извлечение подстрок и многое другое.

#### Пример работы со строками:
```cpp
#include <iostream>
#include <string>

int main() {
    std::string greeting = "Hello, ";
    std::string name = "Alice";

    // Конкатенация строк
    std::string message = greeting + name + "!";
    std::cout << message << std::endl; // Вывод: Hello, Alice!

    // Поиск подстроки
    size_t pos = message.find("Alice");
    if (pos != std::string::npos) {
        std::cout << "Найдено имя на позиции: " << pos << std::endl;
    }

    // Извлечение подстроки
    std::string sub = message.substr(7, 5); // Извлекает "Alice"
    std::cout << "Подстрока: " << sub << std::endl;

    return 0;
}
```

### Важные моменты:
1. **Совместимость**: В тех случаях, когда необходимо взаимодействовать с функциями, принимающими C-строки, `std::string` предоставляет метод `.c_str()`, который возвращает указатель на нуль-терминированную строку:
    ```cpp
    std::string str = "Hello";
    const char* c_str = str.c_str(); // Преобразование в C-строку
    ```

2. **Производительность**: Несмотря на удобство, `std::string` может быть менее производительным при очень частых изменениях строки, так как память может быть перераспределена. В таких случаях можно использовать метод `reserve()`, чтобы заранее зарезервировать память:
    ```cpp
    std::string largeStr;
    largeStr.reserve(1000); // Резервируем место для 1000 символов
    ```

### Общие рекомендации:
- В большинстве случаев **используй `std::string`** вместо нуль-терминированных строк для повышения безопасности и удобства.
- Нуль-терминированные строки могут быть предпочтительны в низкоуровневом коде, где важна максимальная производительность и минимальное использование памяти, но требуют внимательного управления памятью.
